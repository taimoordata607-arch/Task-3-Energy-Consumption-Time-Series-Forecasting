# -*- coding: utf-8 -*-
"""Task 3:Energy Consumption Time Series Forecasting.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pfUecU7fbsfYzqQACDAy1rDuCsbuJtRz

# **Task 3: Energy Consumption Time Series Forecasting**

**Objective:**   
Forecast short-term household energy usage using historical time-based patterns.

## **Summary**
This project focused on the end-to-end analysis and forecasting of Global Active Power consumption. The workflow progressed from rigorous data cleaning and time-series resampling to a comparative evaluation of three distinct forecasting models: ARIMA, Prophet, and XGBoost.   
**1. Data Preparation and Resampling**    
The initial phase ensured a clean, high-integrity dataset for modeling:
**Time-Series Parsing:** 'Date' and 'Time' columns were merged into a single DateTime index to establish a proper chronological structure.
**Missing Value Handling:** The 'Global_active_power' column was converted to numeric types. Any non-numeric entries or gaps were addressed using a combination of forward fill (ffill) and backward fill (bfill), ensuring a continuous data stream.  
**Resampling:** To capture broader trends and reduce noise, the original minute-level data was resampled to a daily frequency, calculating the mean power consumption in kilowatts (kW) for each day.    
**Final Dataset:** The resulting daily_power series spans from December 16, 2006, to December 13, 2008, and exhibits clear seasonal patterns and long-term consumption trends.  
**2. Model Development and Feature Engineering**  
Three models were trained on a split of 583 training entries and 146 testing entries:  
**ARIMA (5,1,0):** A statistical approach focused on auto-regressive properties of the series.   
**Prophet:** Required transforming data into 'ds' (datetime) and 'y' (target) columns, designed to handle seasonality and holidays.   
**XGBoost:** Involved significant feature engineering, including time-based features (hour, day of week, month) and lagging/rolling mean features (e.g., 7-day and 14-day windows) to capture historical dependencies.                        
**3. Performance Results**   
The models were evaluated using Root Mean Squared Error (RMSE) and Mean Absolute![image.png](data:image/png;base64,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)      
Qualitative visualizations supported these metrics, showing that XGBoost's predictions "hugged" the actual data points most closely, while Prophet exhibited the largest deviations.         
**Insights and Future Directions**
**Optimal Model:** XGBoost is the preferred model for deployment due to its superior ability to leverage engineered features like lags and rolling averages.         
**Pipeline Resilience:** The use of explicit assignments for fill operations and conditional checks during preprocessing created a maintainable and robust data pipeline.          
**Next Steps:** Future optimization should focus on hyperparameter tuning, particularly for Prophet (e.g., adding custom regressors or fine-tuning seasonality) to improve its comparative performance.

**Importing Labraries**
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import xgboost as xgb

"""**Loading Data-Set**"""

data = pd.read_csv('household_power_consumption.csv')
data

data.shape

data.head()

data.tail()

"""##**Parse and resample the time series data**

This code combines the 'Date' and 'Time' columns into a single 'DateTime' column, converts it to a proper datetime format, and then sets this new 'DateTime' column as the DataFrame's index. After that, it drops the original 'Date' and 'Time' columns and displays the first few rows of the updated DataFrame.
"""

data['DateTime'] = data['Date'] + ' ' + data['Time']
data['DateTime'] = pd.to_datetime(data['DateTime'], format='%d/%m/%Y %H:%M:%S')
data = data.set_index('DateTime')
data.drop(columns=['Date', 'Time'], inplace=True)
print(data.head())

"""To inspect and handle missing values in the 'Global_active_power' column, I will first check for existing NaNs, then convert the column to numeric, coercing errors to NaN, and finally fill any remaining missing values using forward fill followed by backward fill to ensure no NaNs are left."""

print("Missing values before processing:")
print(data['Global_active_power'].isnull().sum())

# Convert 'Global_active_power' to numeric, coercing errors to NaN
data['Global_active_power'] = pd.to_numeric(data['Global_active_power'], errors='coerce')

# Fill missing values using forward fill then backward fill
data['Global_active_power'].fillna(method='ffill', inplace=True)
data['Global_active_power'].fillna(method='bfill', inplace=True)

print("Missing values after processing:")
print(data['Global_active_power'].isnull().sum())
print(data.head())

"""This code performs two main actions: First, it resamples the 'Global_active_power' column from the data DataFrame to a daily frequency, calculating the mean power consumption for each day and storing it in a new Series called daily_power. Second, it generates a plot of this daily_power Series using matplotlib, visualizing the daily mean global active power consumption over time with a title, axis labels, legend, and grid for clarity."""

# Resample the 'Global_active_power' column to a daily frequency, calculating the mean
daily_power = data['Global_active_power'].resample('D').mean()

# Plot the resampled daily 'Global_active_power'
plt.figure(figsize=(15, 6))
plt.plot(daily_power, label='Daily Global Active Power', color='blue')
plt.title('Daily Mean Global Active Power Consumption')
plt.xlabel('Date')
plt.ylabel('Global Active Power (kilowatts)')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

"""##**Engineer time-based features (e.g., hour of day, weekday/weekend)**

Time-based features can help capture recurring patterns and seasonality in the data. Extracting the hour, day of the week, and week of the year from the DateTime index will allow the model to learn these temporal dependencies. This will be done by creating new columns in the data DataFrame for each feature.
"""

data['hour'] = data.index.hour
data['day_of_week'] = data.index.dayofweek
data['week_of_year'] = data.index.isocalendar().week.astype(int)

print(data.head())

"""##**Compare performance of ARIMA, Prophet, and XGBoost models**

The user wants to ensure the daily power Series is in a suitable time series format for ARIMA modeling. The first step is to verify its current state by checking its index type, value type, and confirming no missing values, as well as checking its frequency. I will use a code block to perform these checks.
"""

print("Type of daily_power index:", daily_power.index)
print("Type of daily_power values:", daily_power.dtype)
print("Missing values in daily_power:", daily_power.isnull().sum())
print("Frequency of daily_power index:", daily_power.index.freq)

# Also check differences between consecutive dates if freq is None
if daily_power.index.freq is None:
    print("Median difference between consecutive dates:", daily_power.index.to_series().diff().dropna().median())

"""The first step in training an ARIMA model is to import the necessary class. I also need to split the data into training and testing sets before fitting the model, so I will include that in the same code block."""

from statsmodels.tsa.arima.model import ARIMA

# Split data into training and testing sets (80% train, 20% test)
train_size = int(len(daily_power) * 0.8)
train_data, test_data = daily_power[0:train_size], daily_power[train_size:]

print(f"Training data length: {len(train_data)}")
print(f"Testing data length: {len(test_data)}")
print("ARIMA class imported and data split into training and testing sets.")

"""I will now fit an ARIMA model to the training data with an initial order, and then generate forecasts for the test period."""

model = ARIMA(train_data, order=(5,1,0))
model_fit = model.fit()

print("ARIMA model fitted.")

# Generate forecasts for the test period
forecast = model_fit.forecast(steps=len(test_data))

# Align forecasts with the test data index
forecast.index = test_data.index

print(f"Forecast generated for {len(forecast)} steps.")
print("First 5 forecast values:\n", forecast.head())

"""I need to convert the daily power Series into a DataFrame and rename its index to 'ds' and its values to 'y', as required by the Prophet model. Then, I will print the head of the new DataFrame to confirm the transformation."""

prophet_df = daily_power.reset_index()
prophet_df.columns = ['ds', 'y']
print(prophet_df.head())

"""The first step in training a Prophet model is to import the Prophet class. Following that, I will split the data into training and testing sets, mirroring the split ratio used for the ARIMA model, as specified in the instructions."""

from prophet import Prophet

# Split data into training and testing sets (80% train, 20% test)
train_size = int(len(prophet_df) * 0.8)
prophet_train_df, prophet_test_df = prophet_df[0:train_size], prophet_df[train_size:]

print(f"Training data length: {len(prophet_train_df)}")
print(f"Testing data length: {len(prophet_test_df)}")
print("Prophet class imported and data split into training and testing sets.")

"""Now that the data is split, I will initialize the Prophet model, fit it to the training data, create a future DataFrame for predictions based on the test data's date range, and then generate forecasts."""

model_prophet = Prophet()
model_prophet.fit(prophet_train_df)

future = model_prophet.make_future_dataframe(periods=len(prophet_test_df), include_history=False)
prophet_forecast = model_prophet.predict(future)

print("Prophet model fitted and forecasts generated.")
print("First 5 prophet forecast values:\n", prophet_forecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].head())

"""The previous Prophet model training and forecasting step completed successfully. The next logical step is to visualize the generated Prophet forecasts against the actual test data to qualitatively assess the model's performance."""

plt.figure(figsize=(15, 6))
plt.plot(prophet_test_df['ds'], prophet_test_df['y'], label='Actual Daily Power', color='blue')
plt.plot(prophet_forecast['ds'], prophet_forecast['yhat'], label='Prophet Forecast', color='red')
plt.fill_between(prophet_forecast['ds'], prophet_forecast['yhat_lower'], prophet_forecast['yhat_upper'], color='pink', alpha=0.3, label='Prophet Confidence Interval')
plt.title('Prophet Forecast vs Actual Daily Global Active Power')
plt.xlabel('Date')
plt.ylabel('Global Active Power (kilowatts)')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

print("Prophet forecasts visualized against actual data.")

""" I need to start by creating the df_xgboost DataFrame from daily_power and renaming its columns to 'ds' and 'y'. Then, I will extract several time-based features such as 'hour', 'day_of_week', 'week_of_year', 'month', and 'year' from the 'ds' column to enrich the dataset for XGBoost.


"""

df_xgboost = daily_power.reset_index()
df_xgboost.columns = ['ds', 'y']

# Extract time-based features
df_xgboost['hour'] = df_xgboost['ds'].dt.hour
df_xgboost['day_of_week'] = df_xgboost['ds'].dt.dayofweek
df_xgboost['week_of_year'] = df_xgboost['ds'].dt.isocalendar().week.astype(int)
df_xgboost['month'] = df_xgboost['ds'].dt.month
df_xgboost['year'] = df_xgboost['ds'].dt.year

print("df_xgboost with initial features:")
print(df_xgboost.head())

"""Now I will create lagged features for the 'y' column, followed by rolling mean features, and then handle any NaN values introduced by these operations using forward and backward fill methods as per the instructions."""

df_xgboost['y_lag1'] = df_xgboost['y'].shift(1)
df_xgboost['y_lag7'] = df_xgboost['y'].shift(7)
df_xgboost['y_lag14'] = df_xgboost['y'].shift(14)

df_xgboost['rolling_mean_7'] = df_xgboost['y'].rolling(window=7).mean()
df_xgboost['rolling_mean_14'] = df_xgboost['y'].rolling(window=14).mean()

# Handle NaN values introduced by lagging and rolling features
df_xgboost.fillna(method='ffill', inplace=True)
df_xgboost.fillna(method='bfill', inplace=True)

print("df_xgboost with all engineered features:")
print(df_xgboost.head(15))

"""The previous code generated a FutureWarning due to the deprecated use of inplace=True with fillna(method=). To resolve this, I will update the fillna calls to explicitly assign the results back to the DataFrame, ensuring future compatibility and maintaining the intended functionality of filling NaN values introduced by lagged and rolling features."""

df_xgboost['y_lag1'] = df_xgboost['y'].shift(1)
df_xgboost['y_lag7'] = df_xgboost['y'].shift(7)
df_xgboost['y_lag14'] = df_xgboost['y'].shift(14)

df_xgboost['rolling_mean_7'] = df_xgboost['y'].rolling(window=7).mean()
df_xgboost['rolling_mean_14'] = df_xgboost['y'].rolling(window=14).mean()

# Handle NaN values introduced by lagging and rolling features
df_xgboost = df_xgboost.ffill()
df_xgboost = df_xgboost.bfill()

print("df_xgboost with all engineered features:")
print(df_xgboost.head(15))

""" I need to split the df_xgboost DataFrame into features (X) and target (y). The target will be the 'y' column, and all other columns except 'ds' will be the features. Then, I will split these into training and testing sets using an 80/20 ratio."""

X = df_xgboost.drop(columns=['ds', 'y'])
y = df_xgboost['y']

train_size = int(len(df_xgboost) * 0.8)
X_train, X_test = X[0:train_size], X[train_size:]
y_train, y_test = y[0:train_size], y[train_size:]

print(f"X_train shape: {X_train.shape}, y_train shape: {y_train.shape}")
print(f"X_test shape: {X_test.shape}, y_test shape: {y_test.shape}")
print("Data split into features, target, training, and testing sets.")

"""Now that the data is split, I will initialize an XGBoost Regressor model, train it on the X_train and y_train data, and then generate predictions for the test set using X_test."""

xg_model = xgb.XGBRegressor(objective='reg:squarederror', n_estimators=100, learning_rate=0.1, random_state=42)
xg_model.fit(X_train, y_train)

xgb_predictions = xg_model.predict(X_test)

print("XGBoost model initialized, trained, and predictions generated.")
print("First 5 XGBoost predictions:\n", xgb_predictions[:5])

"""The XGBoost predictions have been generated. To assess the model's performance qualitatively, I will now visualize these predictions against the actual test data (y_test)."""

plt.figure(figsize=(15, 6))
plt.plot(y_test.index, y_test, label='Actual Daily Power', color='blue')
plt.plot(y_test.index, xgb_predictions, label='XGBoost Predictions', color='green')
plt.title('XGBoost Predictions vs Actual Daily Global Active Power')
plt.xlabel('Date')
plt.ylabel('Global Active Power (kilowatts)')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

print("XGBoost predictions visualized against actual data.")

"""I need to import the necessary metrics from sklearn.metrics to calculate RMSE and MAE, then calculate these metrics for the ARIMA model using the test_data and forecast."""

from sklearn.metrics import mean_squared_error, mean_absolute_error
import numpy as np

# Calculate RMSE and MAE for ARIMA
arima_rmse = np.sqrt(mean_squared_error(test_data, forecast))
arima_mae = mean_absolute_error(test_data, forecast)

print(f"ARIMA RMSE: {arima_rmse:.4f}")
print(f"ARIMA MAE: {arima_mae:.4f}")

"""Now I will calculate the RMSE and MAE for the Prophet model by comparing prophet_test_df['y'] and prophet_forecast['yhat']."""

prophet_rmse = np.sqrt(mean_squared_error(prophet_test_df['y'], prophet_forecast['yhat']))
prophet_mae = mean_absolute_error(prophet_test_df['y'], prophet_forecast['yhat'])

print(f"Prophet RMSE: {prophet_rmse:.4f}")
print(f"Prophet MAE: {prophet_mae:.4f}")

"""Now I will calculate the RMSE and MAE for the XGBoost model by comparing y_test and xgb_predictions."""

xgboost_rmse = np.sqrt(mean_squared_error(y_test, xgb_predictions))
xgboost_mae = mean_absolute_error(y_test, xgb_predictions)

print(f"XGBoost RMSE: {xgboost_rmse:.4f}")
print(f"XGBoost MAE: {xgboost_mae:.4f}")

"""Now that all performance metrics have been calculated, I will print a summary table to clearly compare the RMSE and MAE for all three models (ARIMA, Prophet, and XGBoost)."""

print("\n--- Model Performance Comparison ---")
print(f"ARIMA  - RMSE: {arima_rmse:.4f}, MAE: {arima_mae:.4f}")
print(f"Prophet- RMSE: {prophet_rmse:.4f}, MAE: {prophet_mae:.4f}")
print(f"XGBoost- RMSE: {xgboost_rmse:.4f}, MAE: {xgboost_mae:.4f}")

"""## Visualize Model Forecasts

I need to plot all the model forecasts and actual data on a single graph for visual comparison, following all the instructions provided, including labeling and styling.
"""

plt.figure(figsize=(18, 8))

# Plot the entire daily_power dataset for full context
plt.plot(daily_power.index, daily_power, label='Full Actual Data', color='gray', alpha=0.7)

# Plot actual test data
plt.plot(test_data.index, test_data, label='Actual Test Data', color='blue', linewidth=2)

# Plot ARIMA forecasts
plt.plot(forecast.index, forecast, label='ARIMA Forecast', color='red', linestyle='--')

# Plot Prophet forecasts
plt.plot(prophet_forecast['ds'], prophet_forecast['yhat'], label='Prophet Forecast', color='green', linestyle='-.')

# Plot XGBoost predictions
plt.plot(y_test.index, xgb_predictions, label='XGBoost Prediction', color='purple', linestyle=':')

plt.title('Model Forecasts vs. Actual Daily Global Active Power', fontsize=16)
plt.xlabel('Date', fontsize=12)
plt.ylabel('Global Active Power (kilowatts)', fontsize=12)
plt.legend(fontsize=10)
plt.grid(True)
plt.tight_layout()
plt.show()

print("All model forecasts and actual data plotted for visual comparison.")